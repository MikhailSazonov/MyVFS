# Виртуальная файловая система MyVFS

Главным принципом, которым я руководствовался при разработке системы, было максимальное уменьшение числа системных вызовов и обращений к диску.

Второй принцип - это *end-to-end argument*: в системе практически всё реализовано с нуля, используются очень низкоуровневые примитивы. Причины, по которым это может быть полезно:

1. Платформонезависимость - на разных платформах виртуальная FS будет работать одинаково
2. Прозрачность/редактируемость - виртуальная FS даёт гарантии, на которые можно опираться при написании кода (или наоборот, можно изменить код виртуальной FS, если это потребуется)
3. Эффективность - платим только за то, что нам действительно нужно, при необходимости можем подстроиться под наши потребности (см. пункт 2)

Сама система состоит из 2х главных частей - кэш, лежащий в оперативной памяти, и "файловый менеджер" - класс для работы непосредственно с диском

**Cache**

В системе реализован LRU-Cache, находящийся в оперативной памяти, в дополнение к кэшу, который как правило уже реализован в ОС и используется при работе с диском

Кэш конфигурируется: можно поменять максимальный размер кэша, либо изменить "процент очистки кэша" (при достижении максимального размера кэша отдельный поток-воркер будет удалять наиболее устаревшие данные вплоть до момента, когда занято будет не более X% от максимальной ёмкости кэша)

**FileManager**

Представляет собой обёртку над отдельным потоком-воркером, который занимается взаимодействием с диском

Для оптимизации системных вызовов read/write (и, как следствие, обращений к диску) написан класс SegmentSystem - система отрезков, с возможностью добавлять и удалять отрезки. С помощью этого класса:

* Отслеживается свободное место в физическом файле, чтобы туда писать файлы в нашей системе (виртуальные файлы)
* Оптимизируются записи в физический файл путём слияния находящихся рядом сегментов данных. Т.е., если фрагменты двух файлов находятся рядом, то фрагменты для обоих файлов будут записаны за один вызов write / прочитаны за один вызов read. Таким образом, при удачном расположении виртуальных файлов в физическом файле, количество системных вызовов будет продолжать оставаться низким при сколь угодно высокой степени фрагментации файлов

Сам FileManager сериализует с помощью lock-free очереди задачи на запись в файлы/чтение из файлов, и исполняет их, работая над прогретым кэшом, по аналогии с примитивом синхронизации strand

**Concurrency**

Для работы с виртуальной файловой системой реализованы свои примитивы синхронизации:

- Read-Write Ticket Lock - тикет-лок, реализующий паттерн читателя и писателя (внутри критической секции может находиться один писатель, либо сколь угодно читателей) Реализован вместо std::shared_mutex по причине "честности" - при обычной загруженности системы гарантируется отсутствие продолжительного голодания (std::shared_mutex не даёт таких гарантий) Используется в VFS для создания новых файлов (запись), или работы с уже имеющимися (чтение), в кэше для работы с закэшированными данными: чтением, либо перезаписью/инвалидацией

- MSQueue - очередь Майкла-Скотта - lock-free очередь, управление памятью возложено на отдельный класс Journal, внутри которого реализован garbage collection для удаления старых узлов. Используется в FileManager

**Возможные слабые места**

Наибольшая эффективность системы ожидается, если количество открытых файлов, которое мы можем себе позволить ~ количеству тредов-воркеров, которые мы можем поддерживать в FileManager-ах. Если кол-во открытых файлов >> кол-ва воркеров, то, возможно, будет лучше работать наивная реализация:

Будем хранить std::shared_mutex (либо RWTicketLock, который у нас есть), брать соответствующую блокировку при чтении/записи из/в файл, и работать с физическим файлом, предварительно закрепив один из физических файлов за виртуальным (по тому же round-robin алгоритму, например) Такая реализация может быть эффективней и по причине того, что убираются почти все накладные расходы на вспомогательные классы

**Асинхронность**

Также, данная реализация гораздо эффективнее работает с асинхронными вызовами read/write

**Тестирование**

Тесты находятся в папке Tests/, из неё можно собрать и запустить все тесты командой `make test`

